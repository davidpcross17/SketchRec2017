<!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <title>Project 2</title>
</head>
<body>
   <p>Hello</p>
   <script>

   //used to pop each sketch
    var popped = 0;

    start();

    function start(){
        //Put Json file here!
        //make sure the file is in the same folder as the html file
        //sketch[n].strokes
        var sketchList = readJson("trusses.json");
        //pop sketch

        var sketch = pop(sketchList);
        console.log(sketch);
        //resample sketch
        var resampledSketch = SketchRecTools.resampleByDistance(sketch);
        //find corners
        var corners = findCornersIstraw(sketch);

        //using the corners find the two closests neighbors for each corner
        var NearN, NearstN = Math.pow(2,32) - 1;
        for(var k in corners){
            corner = corners[k];
            dist = SketchRecTools(corner.x,corner.y)
        }

    }

    function euclideanDist(pointA, pointB)
    {
    	x1 = pointA.x;
    	x2 = pointB.x;
    	y1 = pointA.y;
    	y2 = pointB.y;
    	first = x2 - x1;
    	second = y2 - y1;
    	firstSquared = Math.pow(first, 2);
    	secondSquared = Math.pow(second, 2);
    	ret = Math.sqrt(firstSquared + secondSquared);
    	return ret;
    }

    function midpoint(pointA, pointB)
    {
    	retpoint = pointA;
    	x1 = pointA.x;
    	x2 = pointB.x;
    	y1 = pointA.y;
    	y2 = pointB.y;
    	retpoint.x = (x1+x2)/2;
    	retpoint.y = (y1+y2)/2;
    	return retpoint;
    }

    function checkForLine(allPoints, workingCorner, nearestCorner)
    {
    	//Get midpoint, then quarterpoint, then three quarters point
    		//between A and B
    		mid = midpoint(workingCorner,nearestCorner);
    		quarter = midpoint(workingCorner,mid);
    		threeQuarter = midpoint(mid, nearestCorner);
    		isALine = false;

    		//Check if quarter point is within threshold in points list
    		quarterLowx = quarter.x - threshold;
    		quarterLowy = quarter.y - threshold;
    		quarterHighx = quarter.x + threshold;
    		quarterHighy = quarter.y + threshold;
    		quarterExists = false;

    		threeQuarterLowx = threeQuarter.x - threshold;
    		threeQuarterLowy = threeQuarter.y - threshold;
    		threeQuarterHighx = threeQuarter.x + threshold;
    		threeQuarterHighy = threeQuarter.y + threshold;
    		threeQuarterExists = false;

    		for(point in allPoints)
    		{
    			//If qp is within threshold of a point in sketch, then there's a
    			//part of a line
    			if(quarterLowx < point.x &&
    				point.x < quarterHighx &&
    				quarterLowy < point.y &&
    				point.y < quarterHighy)
    			{
    				quarterExists = true;
    			}
    			//if tqp is within threhold of a point in sketch, there's a part
    			//of a line
    			else if(threeQuarterLowx < point.x &&
    				point.x < threeQuarterHighx &&
    				threeQuarterLowy < point.y &&
    				point.y < threeQuarterHighy)
    			{
    				threeQuarterExists = true;
    			}
    		}
    		//if you don't find a line, exit
    		if(quarterExists==true && threeQuarterExists == true)
    		{
    			isALine = true;
    		}
    	return isALine;
    }
    //Function to separate out shapes within a sketch
    function shapeSeparate(corners, allPoints)
    {
    	threshold = 1;
    	var shapesList = [];
    	//go through every corner in the sketch
    	for(int i = 0; i < corners.length; i++)
    	{
    		//Get corner you're working with
    		workingCorner = corners[i];
    		//Reset Distance
    		nearestDist = 9999;
    		//reset corner
    		var nearestCorner = corners[i]; 
    		//Find all corners except the one you're using
    		for(int j = 0; j < corners.length; j++)
    		{
    			//Set current corner
    			currentCorner = corners[j];
    			//Make sure current corner isn't the one you're measuring from
    			if(currentCorner == workingCorner)
    			{
    				continue;
    			}
    			//Find euclidean distance between corner you're working with and
    			//the current corner
    			currentDist = euclideanDist(workingCorner, currentCorner);
    			if(currentDist < nearestDist)
    			{
    				nearestDist = currentDist;
    				nearestCorner = currentCorner;
    			}
    		}
    		if(checkForLine(allPoints,workingCorner,nearestCorner) == false)
    		{
    			continue;
    		}
    		alreadyExists = false;
    		
    		for(shape in shapesList)
    		{
    			for(point in shape)
    			{
    				//If point A is already in a shape, we need only add point B
    				if(point.x == workingCorner.x && point.y == workingCorner.y)
    				{
    					shape.push(nearestCorner);
    					alreadyExists = true;
    				}
    			}
    		}
    		if(alreadyExists == false)
    		{
    			newShape = [];
    			newShape.push(workingCorner);
    			shapesList.push(newShape);
    		}
    	}
    	return shapesList;
    }

    function findTriangle(corners,allPoints)
	{
		triangleList = [];
	    for (var i = 0. i < corners.length; i++)
	    {
	        //Get corner you are working with
	        var workingCorner = corners[i];
	        var shortestDist = 9999;
	        var secondShortestDist = 9999;
	        var nearestCorner = corners[i];
	        var secondNearestCorner = corners[i];
	        for (var j = 0; j < corners.length; j++)
	        {
	            if (corners[j] == workingCorner)
	            {
	                continue;
	            }

	           currentDist = euclideanDist(workingCorner, corners[j]);

	            if (currentDist < shortestDist)
	            {
	                shortestDist = currentDist;
	                nearestCorner = corners[j];
	            }
	            else if (currentDist < secondShortestDist)
	            {
	                secondShortestDist = currentDist;
	                secondNearestCorner = corners[j];
	            }
	        }
	        lineAB = checkForLine(allPoints,workingCorner,nearestCorner);
	        lineAC = checkForLine(allPoints,workingCorner,secondNearestCorner);
	        lineBC = checkForLine(allPoints,nearestCorner,secondNearestCorner);
	        if(lineAB == true && lineAC == true && lineBC == true)
	        {
	        	triangle = [];
	        	triangle.push(workingCorner);
	        	triangle.push(nearestCorner);
	        	triangle.push(secondNearestCorner);
	        	triangleList.push(triangle);
	        }
	    }
	    return triangleList;
	}
    //Need to keep count of pops of Json
    //This is complex (running time) NEED TO BE FIXED
    function pop(sketchList){
        sketch = sketchList[popped];
        popped = 1;
        return sketch;
    }

    //Parse Data from the Json file
    function readJson(fileName) {
         var contents;
         var xhttp = new XMLHttpRequest();
         xhttp.onreadystatechange = function() {
              if (this.readyState === 4 && this.status === 200) {
                 contents = JSON.parse(this.response);
             }
         };
         xhttp.open("GET", fileName, false);
         xhttp.send();
         return contents;
     }


    /********************************************************/
    //Use the corner finding algorithm to find all the corners in the potential truss
    //Courtesy from 624 Sketch Recognition TA --- PAUL TAELE -----
    //URL: http://people.tamu.edu/~ptaele/csce624/
    /*******************************************************/
    function findCornersIstraw(sketch){
        // get the resampled sketch and its corner indices
        var resampledSketch = SketchRecTools.resampleByDistance(sketch);
        var sketchCornerIndices = IStraw.run(resampledSketch);

        // gather the corners from their indices
        var corners = [];
        for (var i = 0; i < resampledSketch.strokes.length; i++) {
            var resampledPoints = resampledSketch.strokes[i].points;
            var strokeCornerIndices = sketchCornerIndices[i];
            for (var j = 0; j < strokeCornerIndices.length; j++) {
                corners.push(resampledPoints[strokeCornerIndices[j]]);
            }
        }
        return corners;
    }
    /*******************************************************/


   </script>
</body>
</html>
